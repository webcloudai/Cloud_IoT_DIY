import json
import logging
import os


# logging level can/will be redefined in any specific Cloud (Lambda/Azure function/etc.)
# predefined here for local
_root_logger = logging.getLogger()
_root_logger.setLevel(level=logging.DEBUG)
# instantiate _top_logger to be used in this code
_top_logger = logging.getLogger(__name__)

# this is import from layer!
# NOTE that we don't include layer to Lambda deployment package
# instead it's deployed separately and made available for Lambdas (see cloud_iot_diy_cloud/cloud_iot_diy_cloud_stack.py)
if os.environ.get("AWS_LAMBDA_FUNCTION_VERSION", None) is None:
    # this part is required for local debugging only!
    import sys
    sys.path.append("./src")

# from _api_handlers_common import aws_common_headers
from _devices_registry import DevicesRegistry, DevicesRegistryFactory, DevicesRegistryType

# define some global variables to benefit from Lambda "hot start"
aws_registry:DevicesRegistry = None

def update_model_command(
        *,
        registry:DevicesRegistry,
        device_id:str,
        device_type:str,
        model_data:dict,
        session_id:str=None,
        response_topic:str=None,
        **kwargs
    )->bool:
    ''' 
        main execution logic here (independent from particular cloud runtime)
        update thing model in the registry
        optionally add info for session_id and/or send confirmation using response_topic
        return command-send status
    '''
    try:
        registry.update_device(
            device_id=device_id,
            device_info=model_data,
            # we MUST update thing type as during provisioning all devices assigned "generic" type
            # BUT devices send messages using real type
            device_type=device_type
        )
        if isinstance(session_id, str):
            # TODO: update session data if session_id provided
            pass
        if isinstance(response_topic, str):
            # TODO: SEND CONFIRMATION over response_topic
            pass
    except Exception as e:
        _top_logger.error(f"update_model_command: FAIL to update device {device_id} model with exception {e}")
        return False

    return True


def lambda_handler(event:dict, context):
    ''' AWS Lambda entry point. Transform event and context to consumable by microservice_logic 
    details on event parameter can be found at:
    - https://docs.aws.amazon.com/lambda/latest/dg/services-iot.html
    - https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-concepts.html#gettingstarted-concepts-event
    - https://docs.aws.amazon.com/lambda/latest/dg/lambda-services.html (see event info for each service)

    details on context parameter can be found at:
    - https://docs.aws.amazon.com/lambda/latest/dg/python-context.html
    - https://github.com/aws/aws-lambda-python-runtime-interface-client/blob/main/awslambdaric/lambda_context.py 

    for this particular function event is exactly the event generated by IoT SQL statement in the rule !
    in our design it'll be a MQTT payload extended with topic and timestamp
    @see 'self.iot_status_injection_rule' in the 'cloud_iot_diy_cloud/cloud_iot_diy_cloud_stack.py' for details
    @example event for 'update-model' content:
    {
        "content": "update-model",
        "session-id": "2db0b7f9-729c-4e3d-8119-53c76524b602",
        "res-topic": "optional <name of the topic to send a response>",
        "data": {
            "measuringInterval|ms|int": "18000",
            "maxAwakeTime|ms|int": "15000",
            "attributes": {
                "serial|hex|str": "C0:49:EF:0B:02:20"
            },
            "dataFieldNames": [
                "air-temperature|C|float",
                "air-pressure|mPa|float",
                "chip-temperature|C|float"
            ],
            "cmdFieldsByCommand": {
                "change-maxawaketime": [
                    "maxawaketime|min|int"
                ],
                "change-measuring-interval": [
                    "measuring-interval|min|int"
                ],
                "restart": [
                    "delay|ms|int"
                ]
            },
            "statusFieldsByType": {}
        },
        "mqtt_topic": "sdt/diyiot/building001/location001/diy/DiyThing/RealThing01",
        "mqtt_timestamp": 1682478264729
    }
    '''
    global aws_registry

    try:
        # This can be extremely useful for understanding of AWS specific parameters
        _top_logger.debug(f"lambda_handler: event type: {type(event)}, context type: {type(context)}")
        _top_logger.debug(f"lambda_handler: event: {event}")
        _top_logger.debug(f"lambda_handler: context: {context}")
        _top_logger.debug(f"lambda_handler: context vars: {vars(context)}")
        # _top_logger.debug(f"lambda_handler ENVironment variables: {os.environ}")
        _top_logger.debug(f"lambda_handler: event json: {json.dumps(event, indent=2)}")
    except Exception as e:
        _top_logger.debug(f"lambda_handler: Exception: {e}")

    try:
        # we'll collect status_topic template to identify part of the mqtt topic containing ThingName
        # status topic template may contain standard prefix so we'll remove it
        status_topic_str = os.environ.get("status_topic","")
        if status_topic_str.startswith("$aws"):
            # we also need to drop first element of the topic which is rule name
            status_topic_template = status_topic_str.replace("$aws/rules/","").split("/")[1:]
        # message topic is just MQTT topic (no info about rules!)
        message_topic = event["mqtt_topic"].split("/")
        # loop through both template and current topic to find out the name and type
        thing_name = None
        thing_type = None
        for (templ,fact) in zip(status_topic_template,message_topic):
            if templ == "{{ thing_name }}":
                thing_name = fact
            if templ == "{{ thing_type }}":
                thing_type = fact
            if thing_name != None and thing_type != None:
                break
        if thing_name is None:
            raise ValueError(f"FAIL to find Thing Name in the mqtt_topic '{message_topic} when template is '{status_topic_template}")
        if thing_type is None:
            raise ValueError(f"FAIL to find Thing Type in the mqtt_topic '{message_topic} when template is '{status_topic_template}")
        message_type = event["content"]
        match message_type:
            case "update-model":
                if aws_registry is None:
                    # init registry
                    aws_registry = DevicesRegistryFactory.create(
                        provider_name=DevicesRegistryType.AwsIotCoreRegistry,
                        config={}
                    )
                res = update_model_command(
                    registry=aws_registry,
                    device_id=thing_name,
                    device_type=thing_type,
                    model_data=event["data"],
                    session_id=event.get("session-id", None),
                    response_topic=event.get("res-topic", None)
                )
                _top_logger.debug(f"Update completed with {res}")
                return

    except Exception as e:
        payload = "ERROR: FAIL to handle status message"
        _top_logger.error(payload)
        _top_logger.error(f"Exception: {e}")
        return

    return
